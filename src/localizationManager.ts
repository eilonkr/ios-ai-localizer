import * as fs from 'fs';
import * as path from 'path';
import * as core from '@actions/core';

// Parses a .strings file content into a key-value object
export function parseStringsFile(content: string): Record<string, string> {
  const strings: Record<string, string> = {};
  // Matches lines like: "key" = "value";
  // Handles comments and empty lines
  const regex = /^"((?:\\"|[^"])+)"\s*=\s*"((?:\\"|[^"])*)"\s*;\s*$/gm;
  let match;
  while ((match = regex.exec(content)) !== null) {
    const key = match[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
    const value = match[2].replace(/\\"/g, '"').replace(/\\n/g, '\n');
    strings[key] = value;
  }
  return strings;
}

// Generates .strings file content from a key-value object
export function generateStringsFileContent(strings: Record<string, string>, baseStrings: Record<string, string>, languageCode: string): string {
  let content = `// Localizable.strings - ${languageCode}\n// Generated by iOS Localizer Action\n\n`;
  // Ensure all keys from baseStrings (AppStrings.swift) are present
  for (const key of Object.keys(baseStrings)) {
    const baseValue = baseStrings[key];
    let translatedValue = strings[key];

    if (translatedValue === undefined) {
        // If key is not in existing translations for this language, add mock translation
        translatedValue = `[MOCK-${languageCode}] ${baseValue}`;
        core.info(`Key "${key}" not found in ${languageCode}.strings. Adding mock translation: "${translatedValue}"`);
    } else {
        // Key exists in the .strings file, keep its current value.
        // Later, with OpenAI, we'd check if baseValue changed compared to previous AppStrings.swift
        // and if so, trigger re-translation for this key.
        // For now, we keep the existing one, even if baseValue changed.
        core.info(`Key "${key}" found in ${languageCode}.strings. Keeping existing value: "${translatedValue}"`);
    }
    
    // Escape quotes and newlines for .strings format
    const escapedKey = key.replace(/"/g, '\\"').replace(/\n/g, '\\n');
    const escapedValue = translatedValue.replace(/"/g, '\\"').replace(/\n/g, '\\n');
    content += `"${escapedKey}" = "${escapedValue}";\n`;
  }
  return content;
}

// Reads a .strings file, creating it with default content if it doesn't exist
export function readLocalizationFile(filePath: string): Record<string, string> {
  if (fs.existsSync(filePath)) {
    const content = fs.readFileSync(filePath, 'utf-8');
    return parseStringsFile(content);
  }
  core.info(`File not found: ${filePath}. It will be created.`);
  return {}; // Return empty if file doesn't exist, it will be created with all keys.
}

// Writes content to a .strings file, creating directories if needed
export function writeLocalizationFile(filePath: string, content: string): void {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    core.info(`Created directory: ${dir}`);
  }
  fs.writeFileSync(filePath, content, 'utf-8');
  core.info(`Successfully wrote to ${filePath}`);
} 